Example Scenario
Imagine a bank account balance:


Initial Balance: $100.
Transaction A: Reads the balance as $100.
Transaction B: Updates the balance to $200 and commits.
Transaction A: Reads the balance again and sees $200 (non-repeatable read).
How Repeatable Reads Solve This
In Repeatable Read isolation:


Transaction A locks the record when it reads it the first time.
Transaction B cannot modify the record until Transaction A completes, ensuring consistent reads.
This is achieved by the database's transaction isolation mechanisms.


how to solve this senario with Transaction when we have more than one instanse in spring


To handle scenarios where multiple instances of your application interact with the same database, you need to ensure proper transaction isolation and concurrency control. Hereâ€™s how you can solve this using Spring and database-level mechanisms:

<hr></hr>
1. Use Proper Isolation Levels
Set the appropriate isolation level in your @Transactional annotation to prevent issues like dirty reads, non-repeatable reads, or phantom reads. For example:

@Transactional(isolation = Isolation.REPEATABLE_READ)
public void updateRecord(Long id, String newValue) {
    // Fetch and update the record
    Record record = recordRepository.findById(id).orElseThrow();
    record.setValue(newValue);
    recordRepository.save(record);
}

REPEATABLE_READ: Ensures that data read during a transaction cannot be modified by other transactions until the current transaction completes.
SERIALIZABLE: Provides the highest level of isolation but may reduce performance due to locking.
<hr></hr>
2. Implement Optimistic Locking
Optimistic locking uses a version field in the database to detect concurrent updates. If two transactions try to update the same record, one will fail, and you can retry the operation.


Example:
Add a @Version field to your entity:


@Entity
public class Record {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String value;

    @Version
    private Integer version; // Used for optimistic locking
}
Handle OptimisticLockException in your service:


@Transactional
public void updateRecord(Long id, String newValue) {
    try {
        Record record = recordRepository.findById(id).orElseThrow();
        record.setValue(newValue);
        recordRepository.save(record);
    } catch (OptimisticLockException e) {
        // Handle conflict (e.g., retry the operation)
        throw new RuntimeException("Conflict detected, please retry", e);
    }
}
<hr></hr>
3. Use Pessimistic Locking
Pessimistic locking prevents other transactions from modifying or reading a record until the current transaction completes.
Example:



@Transactional
public void updateRecord(Long id, String newValue) {
    Record record = entityManager.find(Record.class, id, LockModeType.PESSIMISTIC_WRITE);
    record.setValue(newValue);
    entityManager.persist(record);
}


PESSIMISTIC_WRITE: Prevents other transactions from reading or writing the locked record.
<hr></hr>
4. Database-Level Constraints
Ensure your database enforces constraints like unique keys or foreign keys to prevent data corruption in concurrent environments.

<hr></hr>
5. Distributed Locking (Optional)
If your application runs in a distributed environment, consider using a distributed locking mechanism like Redis or Zookeeper to coordinate access to shared resources.
Example with Redis:


public void updateRecordWithLock(Long id, String newValue) {
    String lockKey = "record:" + id;
    boolean lockAcquired = redisTemplate.opsForValue().setIfAbsent(lockKey, "locked", Duration.ofSeconds(10));

    if (!lockAcquired) {
        throw new RuntimeException("Could not acquire lock, please retry");
    }

    try {
        updateRecord(id, newValue); // Perform the update
    } finally {
        redisTemplate.delete(lockKey); // Release the lock
    }
}
<hr></hr>
Summary
Use isolation levels to control transaction behavior.
Implement optimistic locking for conflict detection and retries.
Use pessimistic locking for strict control over record access.
Consider distributed locks for multi-instance environments.
